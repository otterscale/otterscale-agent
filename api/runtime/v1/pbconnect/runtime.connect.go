// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: api/runtime/v1/runtime.proto

package pbconnect

import (
	connect "connectrpc.com/connect"
	context "context"
	errors "errors"
	v1 "github.com/otterscale/otterscale-agent/api/runtime/v1"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect.IsAtLeastVersion1_13_0

const (
	// RuntimeServiceName is the fully-qualified name of the RuntimeService service.
	RuntimeServiceName = "otterscale.runtime.v1.RuntimeService"
)

// These constants are the fully-qualified names of the RPCs defined in this package. They're
// exposed at runtime as Spec.Procedure and as the final two segments of the HTTP route.
//
// Note that these are different from the fully-qualified method names used by
// google.golang.org/protobuf/reflect/protoreflect. To convert from these constants to
// reflection-formatted method names, remove the leading slash and convert the remaining slash to a
// period.
const (
	// RuntimeServicePodLogProcedure is the fully-qualified name of the RuntimeService's PodLog RPC.
	RuntimeServicePodLogProcedure = "/otterscale.runtime.v1.RuntimeService/PodLog"
	// RuntimeServiceExecuteTTYProcedure is the fully-qualified name of the RuntimeService's ExecuteTTY
	// RPC.
	RuntimeServiceExecuteTTYProcedure = "/otterscale.runtime.v1.RuntimeService/ExecuteTTY"
	// RuntimeServiceWriteTTYProcedure is the fully-qualified name of the RuntimeService's WriteTTY RPC.
	RuntimeServiceWriteTTYProcedure = "/otterscale.runtime.v1.RuntimeService/WriteTTY"
	// RuntimeServiceResizeTTYProcedure is the fully-qualified name of the RuntimeService's ResizeTTY
	// RPC.
	RuntimeServiceResizeTTYProcedure = "/otterscale.runtime.v1.RuntimeService/ResizeTTY"
	// RuntimeServicePortForwardProcedure is the fully-qualified name of the RuntimeService's
	// PortForward RPC.
	RuntimeServicePortForwardProcedure = "/otterscale.runtime.v1.RuntimeService/PortForward"
	// RuntimeServiceWritePortForwardProcedure is the fully-qualified name of the RuntimeService's
	// WritePortForward RPC.
	RuntimeServiceWritePortForwardProcedure = "/otterscale.runtime.v1.RuntimeService/WritePortForward"
	// RuntimeServiceScaleProcedure is the fully-qualified name of the RuntimeService's Scale RPC.
	RuntimeServiceScaleProcedure = "/otterscale.runtime.v1.RuntimeService/Scale"
	// RuntimeServiceRestartProcedure is the fully-qualified name of the RuntimeService's Restart RPC.
	RuntimeServiceRestartProcedure = "/otterscale.runtime.v1.RuntimeService/Restart"
)

// RuntimeServiceClient is a client for the otterscale.runtime.v1.RuntimeService service.
type RuntimeServiceClient interface {
	// PodLog streams log output from a container, similar to `kubectl logs -f`.
	PodLog(context.Context, *v1.PodLogRequest) (*connect.ServerStreamForClient[v1.PodLogResponse], error)
	// ExecuteTTY starts an interactive exec session in a container and streams
	// stdout/stderr back. Due to browser limitations, bidirectional streaming
	// cannot be used; stdin is sent via the separate WriteTTY RPC.
	ExecuteTTY(context.Context, *v1.ExecuteTTYRequest) (*connect.ServerStreamForClient[v1.ExecuteTTYResponse], error)
	// WriteTTY sends stdin data to an active exec session identified by session_id.
	WriteTTY(context.Context, *v1.WriteTTYRequest) (*emptypb.Empty, error)
	// ResizeTTY updates the terminal dimensions of an active exec session.
	ResizeTTY(context.Context, *v1.ResizeTTYRequest) (*emptypb.Empty, error)
	// PortForward opens a port-forward session to a pod and streams data back.
	// Due to browser limitations, bidirectional streaming cannot be used;
	// data to the pod is sent via the separate WritePortForward RPC.
	PortForward(context.Context, *v1.PortForwardRequest) (*connect.ServerStreamForClient[v1.PortForwardResponse], error)
	// WritePortForward sends data to an active port-forward session.
	WritePortForward(context.Context, *v1.WritePortForwardRequest) (*emptypb.Empty, error)
	// Scale updates the replica count of a scalable workload
	// (Deployment, StatefulSet, ReplicaSet) via the /scale subresource.
	Scale(context.Context, *v1.ScaleRequest) (*v1.ScaleResponse, error)
	// Restart triggers a rolling restart of a workload by patching the
	// pod template annotation, equivalent to `kubectl rollout restart`.
	Restart(context.Context, *v1.RestartRequest) (*emptypb.Empty, error)
}

// NewRuntimeServiceClient constructs a client for the otterscale.runtime.v1.RuntimeService service.
// By default, it uses the Connect protocol with the binary Protobuf Codec, asks for gzipped
// responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply the
// connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewRuntimeServiceClient(httpClient connect.HTTPClient, baseURL string, opts ...connect.ClientOption) RuntimeServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	runtimeServiceMethods := v1.File_api_runtime_v1_runtime_proto.Services().ByName("RuntimeService").Methods()
	return &runtimeServiceClient{
		podLog: connect.NewClient[v1.PodLogRequest, v1.PodLogResponse](
			httpClient,
			baseURL+RuntimeServicePodLogProcedure,
			connect.WithSchema(runtimeServiceMethods.ByName("PodLog")),
			connect.WithClientOptions(opts...),
		),
		executeTTY: connect.NewClient[v1.ExecuteTTYRequest, v1.ExecuteTTYResponse](
			httpClient,
			baseURL+RuntimeServiceExecuteTTYProcedure,
			connect.WithSchema(runtimeServiceMethods.ByName("ExecuteTTY")),
			connect.WithClientOptions(opts...),
		),
		writeTTY: connect.NewClient[v1.WriteTTYRequest, emptypb.Empty](
			httpClient,
			baseURL+RuntimeServiceWriteTTYProcedure,
			connect.WithSchema(runtimeServiceMethods.ByName("WriteTTY")),
			connect.WithClientOptions(opts...),
		),
		resizeTTY: connect.NewClient[v1.ResizeTTYRequest, emptypb.Empty](
			httpClient,
			baseURL+RuntimeServiceResizeTTYProcedure,
			connect.WithSchema(runtimeServiceMethods.ByName("ResizeTTY")),
			connect.WithClientOptions(opts...),
		),
		portForward: connect.NewClient[v1.PortForwardRequest, v1.PortForwardResponse](
			httpClient,
			baseURL+RuntimeServicePortForwardProcedure,
			connect.WithSchema(runtimeServiceMethods.ByName("PortForward")),
			connect.WithClientOptions(opts...),
		),
		writePortForward: connect.NewClient[v1.WritePortForwardRequest, emptypb.Empty](
			httpClient,
			baseURL+RuntimeServiceWritePortForwardProcedure,
			connect.WithSchema(runtimeServiceMethods.ByName("WritePortForward")),
			connect.WithClientOptions(opts...),
		),
		scale: connect.NewClient[v1.ScaleRequest, v1.ScaleResponse](
			httpClient,
			baseURL+RuntimeServiceScaleProcedure,
			connect.WithSchema(runtimeServiceMethods.ByName("Scale")),
			connect.WithClientOptions(opts...),
		),
		restart: connect.NewClient[v1.RestartRequest, emptypb.Empty](
			httpClient,
			baseURL+RuntimeServiceRestartProcedure,
			connect.WithSchema(runtimeServiceMethods.ByName("Restart")),
			connect.WithClientOptions(opts...),
		),
	}
}

// runtimeServiceClient implements RuntimeServiceClient.
type runtimeServiceClient struct {
	podLog           *connect.Client[v1.PodLogRequest, v1.PodLogResponse]
	executeTTY       *connect.Client[v1.ExecuteTTYRequest, v1.ExecuteTTYResponse]
	writeTTY         *connect.Client[v1.WriteTTYRequest, emptypb.Empty]
	resizeTTY        *connect.Client[v1.ResizeTTYRequest, emptypb.Empty]
	portForward      *connect.Client[v1.PortForwardRequest, v1.PortForwardResponse]
	writePortForward *connect.Client[v1.WritePortForwardRequest, emptypb.Empty]
	scale            *connect.Client[v1.ScaleRequest, v1.ScaleResponse]
	restart          *connect.Client[v1.RestartRequest, emptypb.Empty]
}

// PodLog calls otterscale.runtime.v1.RuntimeService.PodLog.
func (c *runtimeServiceClient) PodLog(ctx context.Context, req *v1.PodLogRequest) (*connect.ServerStreamForClient[v1.PodLogResponse], error) {
	return c.podLog.CallServerStream(ctx, connect.NewRequest(req))
}

// ExecuteTTY calls otterscale.runtime.v1.RuntimeService.ExecuteTTY.
func (c *runtimeServiceClient) ExecuteTTY(ctx context.Context, req *v1.ExecuteTTYRequest) (*connect.ServerStreamForClient[v1.ExecuteTTYResponse], error) {
	return c.executeTTY.CallServerStream(ctx, connect.NewRequest(req))
}

// WriteTTY calls otterscale.runtime.v1.RuntimeService.WriteTTY.
func (c *runtimeServiceClient) WriteTTY(ctx context.Context, req *v1.WriteTTYRequest) (*emptypb.Empty, error) {
	response, err := c.writeTTY.CallUnary(ctx, connect.NewRequest(req))
	if response != nil {
		return response.Msg, err
	}
	return nil, err
}

// ResizeTTY calls otterscale.runtime.v1.RuntimeService.ResizeTTY.
func (c *runtimeServiceClient) ResizeTTY(ctx context.Context, req *v1.ResizeTTYRequest) (*emptypb.Empty, error) {
	response, err := c.resizeTTY.CallUnary(ctx, connect.NewRequest(req))
	if response != nil {
		return response.Msg, err
	}
	return nil, err
}

// PortForward calls otterscale.runtime.v1.RuntimeService.PortForward.
func (c *runtimeServiceClient) PortForward(ctx context.Context, req *v1.PortForwardRequest) (*connect.ServerStreamForClient[v1.PortForwardResponse], error) {
	return c.portForward.CallServerStream(ctx, connect.NewRequest(req))
}

// WritePortForward calls otterscale.runtime.v1.RuntimeService.WritePortForward.
func (c *runtimeServiceClient) WritePortForward(ctx context.Context, req *v1.WritePortForwardRequest) (*emptypb.Empty, error) {
	response, err := c.writePortForward.CallUnary(ctx, connect.NewRequest(req))
	if response != nil {
		return response.Msg, err
	}
	return nil, err
}

// Scale calls otterscale.runtime.v1.RuntimeService.Scale.
func (c *runtimeServiceClient) Scale(ctx context.Context, req *v1.ScaleRequest) (*v1.ScaleResponse, error) {
	response, err := c.scale.CallUnary(ctx, connect.NewRequest(req))
	if response != nil {
		return response.Msg, err
	}
	return nil, err
}

// Restart calls otterscale.runtime.v1.RuntimeService.Restart.
func (c *runtimeServiceClient) Restart(ctx context.Context, req *v1.RestartRequest) (*emptypb.Empty, error) {
	response, err := c.restart.CallUnary(ctx, connect.NewRequest(req))
	if response != nil {
		return response.Msg, err
	}
	return nil, err
}

// RuntimeServiceHandler is an implementation of the otterscale.runtime.v1.RuntimeService service.
type RuntimeServiceHandler interface {
	// PodLog streams log output from a container, similar to `kubectl logs -f`.
	PodLog(context.Context, *v1.PodLogRequest, *connect.ServerStream[v1.PodLogResponse]) error
	// ExecuteTTY starts an interactive exec session in a container and streams
	// stdout/stderr back. Due to browser limitations, bidirectional streaming
	// cannot be used; stdin is sent via the separate WriteTTY RPC.
	ExecuteTTY(context.Context, *v1.ExecuteTTYRequest, *connect.ServerStream[v1.ExecuteTTYResponse]) error
	// WriteTTY sends stdin data to an active exec session identified by session_id.
	WriteTTY(context.Context, *v1.WriteTTYRequest) (*emptypb.Empty, error)
	// ResizeTTY updates the terminal dimensions of an active exec session.
	ResizeTTY(context.Context, *v1.ResizeTTYRequest) (*emptypb.Empty, error)
	// PortForward opens a port-forward session to a pod and streams data back.
	// Due to browser limitations, bidirectional streaming cannot be used;
	// data to the pod is sent via the separate WritePortForward RPC.
	PortForward(context.Context, *v1.PortForwardRequest, *connect.ServerStream[v1.PortForwardResponse]) error
	// WritePortForward sends data to an active port-forward session.
	WritePortForward(context.Context, *v1.WritePortForwardRequest) (*emptypb.Empty, error)
	// Scale updates the replica count of a scalable workload
	// (Deployment, StatefulSet, ReplicaSet) via the /scale subresource.
	Scale(context.Context, *v1.ScaleRequest) (*v1.ScaleResponse, error)
	// Restart triggers a rolling restart of a workload by patching the
	// pod template annotation, equivalent to `kubectl rollout restart`.
	Restart(context.Context, *v1.RestartRequest) (*emptypb.Empty, error)
}

// NewRuntimeServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewRuntimeServiceHandler(svc RuntimeServiceHandler, opts ...connect.HandlerOption) (string, http.Handler) {
	runtimeServiceMethods := v1.File_api_runtime_v1_runtime_proto.Services().ByName("RuntimeService").Methods()
	runtimeServicePodLogHandler := connect.NewServerStreamHandlerSimple(
		RuntimeServicePodLogProcedure,
		svc.PodLog,
		connect.WithSchema(runtimeServiceMethods.ByName("PodLog")),
		connect.WithHandlerOptions(opts...),
	)
	runtimeServiceExecuteTTYHandler := connect.NewServerStreamHandlerSimple(
		RuntimeServiceExecuteTTYProcedure,
		svc.ExecuteTTY,
		connect.WithSchema(runtimeServiceMethods.ByName("ExecuteTTY")),
		connect.WithHandlerOptions(opts...),
	)
	runtimeServiceWriteTTYHandler := connect.NewUnaryHandlerSimple(
		RuntimeServiceWriteTTYProcedure,
		svc.WriteTTY,
		connect.WithSchema(runtimeServiceMethods.ByName("WriteTTY")),
		connect.WithHandlerOptions(opts...),
	)
	runtimeServiceResizeTTYHandler := connect.NewUnaryHandlerSimple(
		RuntimeServiceResizeTTYProcedure,
		svc.ResizeTTY,
		connect.WithSchema(runtimeServiceMethods.ByName("ResizeTTY")),
		connect.WithHandlerOptions(opts...),
	)
	runtimeServicePortForwardHandler := connect.NewServerStreamHandlerSimple(
		RuntimeServicePortForwardProcedure,
		svc.PortForward,
		connect.WithSchema(runtimeServiceMethods.ByName("PortForward")),
		connect.WithHandlerOptions(opts...),
	)
	runtimeServiceWritePortForwardHandler := connect.NewUnaryHandlerSimple(
		RuntimeServiceWritePortForwardProcedure,
		svc.WritePortForward,
		connect.WithSchema(runtimeServiceMethods.ByName("WritePortForward")),
		connect.WithHandlerOptions(opts...),
	)
	runtimeServiceScaleHandler := connect.NewUnaryHandlerSimple(
		RuntimeServiceScaleProcedure,
		svc.Scale,
		connect.WithSchema(runtimeServiceMethods.ByName("Scale")),
		connect.WithHandlerOptions(opts...),
	)
	runtimeServiceRestartHandler := connect.NewUnaryHandlerSimple(
		RuntimeServiceRestartProcedure,
		svc.Restart,
		connect.WithSchema(runtimeServiceMethods.ByName("Restart")),
		connect.WithHandlerOptions(opts...),
	)
	return "/otterscale.runtime.v1.RuntimeService/", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		switch r.URL.Path {
		case RuntimeServicePodLogProcedure:
			runtimeServicePodLogHandler.ServeHTTP(w, r)
		case RuntimeServiceExecuteTTYProcedure:
			runtimeServiceExecuteTTYHandler.ServeHTTP(w, r)
		case RuntimeServiceWriteTTYProcedure:
			runtimeServiceWriteTTYHandler.ServeHTTP(w, r)
		case RuntimeServiceResizeTTYProcedure:
			runtimeServiceResizeTTYHandler.ServeHTTP(w, r)
		case RuntimeServicePortForwardProcedure:
			runtimeServicePortForwardHandler.ServeHTTP(w, r)
		case RuntimeServiceWritePortForwardProcedure:
			runtimeServiceWritePortForwardHandler.ServeHTTP(w, r)
		case RuntimeServiceScaleProcedure:
			runtimeServiceScaleHandler.ServeHTTP(w, r)
		case RuntimeServiceRestartProcedure:
			runtimeServiceRestartHandler.ServeHTTP(w, r)
		default:
			http.NotFound(w, r)
		}
	})
}

// UnimplementedRuntimeServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedRuntimeServiceHandler struct{}

func (UnimplementedRuntimeServiceHandler) PodLog(context.Context, *v1.PodLogRequest, *connect.ServerStream[v1.PodLogResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("otterscale.runtime.v1.RuntimeService.PodLog is not implemented"))
}

func (UnimplementedRuntimeServiceHandler) ExecuteTTY(context.Context, *v1.ExecuteTTYRequest, *connect.ServerStream[v1.ExecuteTTYResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("otterscale.runtime.v1.RuntimeService.ExecuteTTY is not implemented"))
}

func (UnimplementedRuntimeServiceHandler) WriteTTY(context.Context, *v1.WriteTTYRequest) (*emptypb.Empty, error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("otterscale.runtime.v1.RuntimeService.WriteTTY is not implemented"))
}

func (UnimplementedRuntimeServiceHandler) ResizeTTY(context.Context, *v1.ResizeTTYRequest) (*emptypb.Empty, error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("otterscale.runtime.v1.RuntimeService.ResizeTTY is not implemented"))
}

func (UnimplementedRuntimeServiceHandler) PortForward(context.Context, *v1.PortForwardRequest, *connect.ServerStream[v1.PortForwardResponse]) error {
	return connect.NewError(connect.CodeUnimplemented, errors.New("otterscale.runtime.v1.RuntimeService.PortForward is not implemented"))
}

func (UnimplementedRuntimeServiceHandler) WritePortForward(context.Context, *v1.WritePortForwardRequest) (*emptypb.Empty, error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("otterscale.runtime.v1.RuntimeService.WritePortForward is not implemented"))
}

func (UnimplementedRuntimeServiceHandler) Scale(context.Context, *v1.ScaleRequest) (*v1.ScaleResponse, error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("otterscale.runtime.v1.RuntimeService.Scale is not implemented"))
}

func (UnimplementedRuntimeServiceHandler) Restart(context.Context, *v1.RestartRequest) (*emptypb.Empty, error) {
	return nil, connect.NewError(connect.CodeUnimplemented, errors.New("otterscale.runtime.v1.RuntimeService.Restart is not implemented"))
}
